# 1.6 마이크로서비스 아키텍쳐 패턴 언어

당야한 아키텍쳐와 설계 옵션을 기술하고 더 나은 결정을 내리는 좋은 방법은 패턴 언어를 사용하는 것입니다.



## 1.6.1 마이크로서비스 아키텍쳐도 만병통치약은 아니다

모든 기술은 일장일단이 있기 때문에 어떤 기술을 택하더라도 생산성을 갑자기 10배로 만들어주는 기법/기술은 없습니다.

마이크로서비스 역시 어떤 애플리케이션에 적합할지는 여러 요인에 따라 달라지므로 무턱대고 사용할 수 만은 없습니다.



## 1.6.2 패턴 및 패턴 언어

패턴은 특정한 상황에서 발생한 문제에 대한 재사용 가능한 해법입니다.

실제로 소프트웨어 아키텍처 및 설계 분야에서 이미 검증된 유용한 아이디어입니다.

상용 패턴의 구조는 대략 다음 세 부분으로 구성됩니다.

<br>

### 강제조항: 문제 해결을 위해 반드시 처리해야 할 이슈

주어진 맥락에서 문제를 해결하고자 할 때 반드시 처리해야 할 강제 조항입니다.

상충하는 강제 조항도 있기 떄문에 모든 조항을 전부 충족할 수는 없고, 어느 조항이 중요한지는 맥락에 따라 다르므로 우선순위를 정해야 합니다.



### 결과 맥락: 패턴 적용 결과

패턴을 적용한 결과를 다음 세 부분으로 기술합니다.

* 장점 : 패턴의 좋은 점
* 단점 : 패턴의 나쁜 점
* 이슈 : 패턴 적용 시 발생한 새로운 문제점



### 연관 패턴: 다섯 가지 관계 유형

한 패턴과 다른 패턴의 관계를 기술하는 영역입니다.

패턴 관계는 다섯가지 종류가 있습니다.

* 선행자 : 이 패턴을 필요하게 만든 선행 패턴
* 후행자 : 이 패턴으로 야기된 이슈를 해결하는 패턴
* 대안 : 이 패턴의 대체 솔루션을 제공하는 패턴
* 일반화 : 문제를 해결하는 일반적인 솔루션에 해당하는 패턴
* 세분화 : 특정 패턴을 더 세부적으로 나타낸 형태



특정 영역의 문제를 해결하는 연관된 패턴을 한데 묶어 명시적으로 기술하면 어떻게 문제를 해결할 수 있는지 효과적으로 나타낼 수 있습니다.

![image-20210930210331091](../images/Chapter01/패턴_exp1.png)



패턴 간 관계 역시 몇 가지 유형이 있습니다.

* 선행자-후행자 관계를 표현
* 같은 문제를 다른 방법으로 해결하는 패턴
* 한 패턴이 다른 패턴을 구체화한 패턴임을 표시
* 특정 영역의 문제에 적용되는 패턴



<br>

## 1.6.3 마이크로서비스 아키텍쳐 패턴 언어 개요

아래 그림을 봅시다.

왼쪽은 모놀리식 아키텍쳐 패턴과 마이크로서비스 아키텍처 패턴이 위치한 애플리케이션 아키텍처 패턴 그룹이고,

나머지는 마이크로서비스 아키텍쳐 패턴 사용 시 각종 이슈를 해결하는 솔루션 패턴을 모아놓은 패턴 그룹입니다.

![image-20210930214418748](../../../../Library/Application Support/typora-user-images/image-20210930214418748.png)

패턴은 다시 세 계층으로 분류됩니다.

* 인프라 패턴 : 주로 개발 영역 밖의 인프라 문제를 해결합니다.
* 애플리케이션 인프라 : 개발에도 영향을 미치는 인프라 문제를 해결합니다.
* 애플리케이션 패턴 : 개발자가 맞닥뜨리는 문제를 해결합니다.



<br>

### 애플리케이션을 여러 서비스로 분해하는 패턴

한 시스템을 여러 서비스로 분해하는 방법을 결정하는 것이 진짜 기술인데 참고할 만한 유용한 전략이 많습니다.

![image-20210930230303141](../images/Chapter01/분해패턴.png)

<br>

### 통신 패턴

MSA간 애플리케이션은 분산 시스템이기 때문에 프로세스 간 통신이 아주 중요합니다.

통신 패턴은 크게 다섯 그룹으로 정리할 수 있습니다.

* 통신 스타일 : 어떤 종류의 IPC를 사용하는가
* 디스커버리 : 서비스 클라이언트는 서비스 인스턴스의 IP 주소를 어떻게 가져오는가
* 신뢰성 : 서비스 불능 시 서비스 간 통신의 신뢰성은 어떻게 보장되는가
* 트랜잭셔널 메시징 : 비즈니스 데이터를 업데이트하는 DB 트랜잭션에 메세지를 송신하고 이벤트를 발행하는 행위를 어떻게 통합하는가
* 외부 API : 애플리케이션 클라이언트는 서비스와 어떻게 통신하는가

![image-20210930231538756](../images/Chapter01/통신패턴.png)

<br>

### 트랜잭션 관리를 위한 데이터 일관성 패턴

서비스마다 DB를 따로 두면 사가 패턴에 따라 데이터 일관성을 유지해야합니다.

![image-20210930231944624](../images/Chapter01/일관성패턴.png)



<br>

### 데이터 쿼리 패턴

서비스마다 DB를 두면 각 서비스가 소유한 데이터를 조인하는 쿼리도 문제입니다.

아래 두 가지 패턴을 응용해서 구현할 수 있습니다.

![image-20210930232106194](../images/Chapter01/데이터쿼리패턴.png)



<br>

### 서비스 배포 패턴

예전에는 보통 언어에 특정한 패키징 포맷으로 애플리케이션을 수동 배포했습니다.

MSA에서는 단순한 UI로 서비스를 배포/관리하고 가상 머신, 컨테이너, 서버리스 기술을 응용한 배포 플랫폼이 바람직합니다.

![image-20210930232306110](../images/Chapter01/서비스배포패턴.png)



<br>

### 관측성 패턴: 애플리케이션 동작 파악

MSA는 요청 결과가 클라이언트에 반환되기까지 어떤 서비스를 어떻게 오갈지 알 수 없기 때문에 로그 파일 하나만으로는 원인을 파악할 수 없고 문제의 원인을 찾고 진단하기가 매우 복잡합니다.

관측 가능한 서비스를 설계하려면 다음과 같은 패턴이 필요합니다.

* 헬스 체크 API : 서비스 가동상태를 반환하는 endpoint를 표출합니다.
* 로그 수집 : 서비스 내역을 기록하고 중앙 로깅 서버에 로그를 출력하여 검색/경고 기능을 제공합니다.
* 분산 추적 : 각 외부 요청마다 ID를 부여하여 서비스를 통과하는 과정을 추적합니다.
* 예외 추적 : 예외가 발생하면 예외 추적 서비스에 보고합니다.
* 애플리케이션 지표 : 카운터, 게이지 등의 지표를 측정하여 지표 서버에 표출합니다.
* 감사 로깅 : 사용자가 한 일을 기록합니다.



<br>

### 서비스 테스트 자동화 패턴

MSA는 단위 서비스 크기가 작아서 테스트하기 쉽지만 서로 다른 여러 서비스가 조화롭게 잘 작동되는지 테스트하는 일이 중요합니다.

느리고 복잡한, 취약한 end-to-end test는 가급적 피하는 것이 상책입니다.

따라서 다음과 같이 서비스를 따로 분리해서 테스트하는 테스트 단순화 패턴이 필요합니다.

* 컨슈머 주도 계약 테스트 : 클라이언트가 의도한 대로 서비스가 동작하는지 확인합니다.
* 컨슈머 쪽 계약 테스트 : 클라이언트와 서비스가 상호 통신 가능한지 확인합니다.
* 서비스 컴포넌트 테스트 : 서비스를 따로따로 테스트합니다.



<br>

### 횡단 관심사 처리 패턴

신규 서비스 구축 시 이런 횡단 관심사를 처음부터 다시 개발하려면 시간이 너무 많이 걸립니다.

따라서 횡단 관심사를 처리하는 프레임워크에서 MSA 섀시 패턴을 적용하여 서비스를 구축하는 편이 바람직합니다.



<br>

### 보안 패턴

MSA에서는 일반적으로 API 게이트웨이가 신원, 역할 등 사용자 정보를 인증한 후 호출할 서비스에 관련 정보를 전달합니다.

가장 일반적인 솔루션은 JWT 같은 액세스 토큰 패턴을 적용하는 것 입니다.

API 게이트웨이는 액세스 토근을 서비스에 건네고 서비스는 토큰 확인 후 사용자 정보를 조회합니다.

