# 3.1 마이크로서비스 아키텍처 IPC 개요

서비스에 적용가능한 IPC 기술은 정말 선택의 폭이 넓습니다.

HTTP 기반 REST나 gRPC 등 동기 요청/응답 기반의 통신 메커니즘도 있고 AMQP, STOMP 등 비동기 메세지 기반의 통신 메커니즘도 있습니다.

메세지 포맷 역시 JSON, XML처럼 인강이 읽을 수 있는 텍스트 포맷부터 아브로, 프로토콜 버퍼처럼 효율이 우수한 이진 포맷까지 다양합니다.



## 3.1.1 상호 작용 스타일 

서비스 API에 알맞은 IPC를 선택하기 전에 클라이언트/서비스 간 상호 작용 스타일을 잘 살펴봐야 합니다.

클라이언트/서비스 상호 작용 스타일은 다양하지만 두 가지 기준으로 분류할 수 있습니다.

1. 일대일/일대다 여부
   * 일대일 : 각 클라이언트의 요청은 정확히 한 서비스가 처리합니다.
   * 일대다 : 각 클라이언트 요청을 여러 서비스가 협동하여 처리합니다.
2. 동기/비동기 여부
   * 동기 : 클라이언트는 서비스가 제 시간에 응답하리라 기대하고 대기 도중 블로킹할 수 있습니다.
   * 비동기 : 클라이언트가 블로킹하지 않습니다. 응답은 즉시 전송되지 않아도 됩니다.

<br>

일대일 상호 작용도 종류는 다양합니다.

* 요청/응답 : 클라이언트는 서비스에 요청을 하고 응답을 기다립니다. 서비스가 서로 강하게 결합됩니다.
* 비동기 요청/응답 : 클라이언트는 서비스에 요청을 하고 서비스는 비동기적으로 응답합니다. 클라이언트는 대기 중에 블로킹하지 않고 서비스는 오랫동안 응답하지 않을 수 있습니다.
* 단방향 알림 : 클라이언트는  서비스에 일방적으로 요청만 하고 서비스는 응답을 보내지 않습니다.

<br>

일대다 상호 작용도 몇 가지 종류가 있습니다.

* 발행/구독 : 클라이언트는 알림 메세지를 발행하고 여기에 관심있는 0개 이상의 서비스가 메세지를 소비합니다.
* 발행/비동기 응답 : 클라이언트는 요청 메세지를 발행하고 주어진 시간 동안 관련 서비스가 응답하길 기다립니다.

<br>

## 3.1.2 마이크로서비스 API 정의

MSA에서는 API와 인터페이스가 똑같이 중요합니다.

문제는 서비스 API가 단순한 프로그래밍 언어의 일부가 아니라는 점입니다.

정의상 서비스와 클라이언트는 함께 컴파일되지 않습니다.

따라서 새 버전의 서비스가 호환되지 않는 API에 맞물려 배포되어도 컴파일 에러는 안나고 런타임에 조용히 실패할 것 입니다.

API는 어떤 IPC를 사용하느냐에 따라 그 내용이 결정됩니다.

<br>

## 3.1.3 API 발전시키기

API는 새 기능을 추가하거나 기존 기능을 변경/삭제하는 과정을 거치며 계속 변합니다.

모놀리식 애플리케이션은 API를 변경하고 모든 호출부를 수정하는 일이 그리 어렵지 않습니다.

MSA는 클라이언트를 다른 서비스 팀이 개발한 경우가 대부분이기 때문에 서비스 API를 변경하기가 무척 어렵습니다.

<br>

### 시맨틱 버저닝 

시맨틱 버저닝 명세는 API 버저닝에 관한 유용한 지침서입니다.

여기에는 버전 번호를 사용하고 증가시키는 규칙들이 명시되어 있습니다.

시맨틱 버저닝은 원래 소프트웨어 패키지의 버저닝 용도로 쓰였지만, 분산 시스템은 API 버저닝에도 사용할 수 있습니다.

버전 번호를  `MAJOR.MINOR.PATCH` 세 파트로 구성하고 다음 규칙에 따라 각각 증가시킵니다.

* MAJOR : 하위 호환되지 않는 변경분을 API에 적용 시 
* MINOR : 하위 호환되는 변경분을 API에 적용 시 
* PATCH : 하위 호환되는 오류 수정 시

이러한 버전 번호를 REST API라면 메이저 버전을 URL 경로의 첫 번째 엘리먼트로 쓸 수 있고, 메시징 기반의 서비스라면 이 서비스가 발행한 메세지에 버전 번호를 넣을 수 있습니다.

<br>

### 하위 호환되는 소규모 변경

변경을 하더라도 가급적 하위 호환성을 보장하는 방향으로 해야합니다.

뭔가 API에 추가하는 변경은 대부분 하위 호환됩니다.

* 옵션 속성을 요청에 추가
* 속성을 응답에 추가
* 새 작업을 추가

이런 종류의 변경은 새 서비스에 적용해도 기존 클라이언트 역시 별 문제없이 동작합니다.

<br>

### 중대한 대규모 변경

경우에 따라서는 매우 중요한, 기존 버전과 호환이 안되는 변경을 API에 적용해야 할 때가 있습니다.

일시에 클라이언트를 강제로 업그레이드 하는 것은 불가하므로 일정 기간 동안 서비스는 신구 버전 API를 모두 지원해야 합니다.

REST API라면 URL에 메이저 버전 번호를 삽입할 수 있습니다.(/v1/, /v2/ 등)



HTTP 컨텐트 협상을 이용해서 MIME 타입 내부에 버전 번호를 끼워 넣는 방법도 있습니다.

예를 들어 1.X의 주문은 클라이언트가 이렇게 요청합니다.

```
GET /orders/xyz HTTP/1.1
Accept: application/vnd.example.resource+json; version=1
```

여러 버전의 API를 지원하려면 API가 구현된 서비스 어댑터에 신구 버전을 올바르게 중계하는 로직이 있어야 합니다.

API 게이트웨이는 반드시 버저닝된 API를 사용하며 심지어는 구 버전 API도 여러 버전을 지원해야 하는 경우도 있습니다.

<br>

## 3.1.4 메세지 포맷

IPC의 핵심은 메세지 교환입니다.

어느 프로그래밍 언어로 MSA를 작성하더라도 나중에 다른 언어를 사용해서 작성하게 될 수도 있기 때문에 범언어적 메세지 포맷을 선택하는 것이 중요합니다.

메세지 포맷은 크게 텍스트와 이진 포맷으로 분류됩니다.

<br>

### 텍스트 메세지 포맷

JSON, XML 등 텍스트 기반 포맷은 사람이 읽을 수 있고 그 자체적으로 의미가 분명합니다.

메세지 컨슈머는 자신이 관심있는 값만 골라쓰고 나머지는 그냥 무시하면 되므로 메세지 스키마가 자주 바뀌어도 하위 호환성은 쉽게 보장됩니다.

텍스트 메세지 포맷의 단점은 메세지가 다소 길다는 사실입니다.

속성값 이외에 속성명이 추가되는 오버헤드가 있고 덩치가 큰 메세지는 텍스트를 파싱하는 오버헤드도 있습니다.

<br>

### 이진 메세지 포맷

이진 포맷도 종류가 다양하지만 프로토콜 버퍼와 아브로가 유명합니다.

두 포맷은 메세지 구조 정의에 필요한 타입 IDL(Interface Description Language)을 제공하며, 컴파일러는 메세지를 직렬화/역직렬화하는 코드를 생성합니다.

에이브로 vs 프로토콜 버퍼 vs 스리프트

http://sjava.net/2012/12/%EB%B2%88%EC%97%AD-%EC%97%90%EC%9D%B4%EB%B8%8C%EB%A1%9Cavro-%ED%94%84%EB%A1%9C%ED%86%A0%EC%BD%9C-%EB%B2%84%ED%8D%BCprotocol-buffers-%EC%93%B0%EB%A6%AC%ED%94%84%ED%8A%B8thrift%EC%9D%98-%EC%8A%A4/

