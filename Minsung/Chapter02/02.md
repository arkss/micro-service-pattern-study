# 2.2 마이크로서비스 아키텍쳐 정의

이 장에서는 애플리케이션 아키텍쳐를 정의하는 3단계 프로세스를 설명합니다.

![image-20211002193322345](../images/Chapter02/MSA정의프로세스1.png)

![image-20211002193332957](../images/Chapter02/MSA정의프로세스2.png)

1단계 : 애플리케이션 요건을 핵심 요청으로 추출하는 것입니다.

2단계 : 어떻게 여러 서비스로 분해할지 결정하는 것입니다. 비즈니스 능력에 따라 서비스를 정의할 수도 있고 DDD의 하위 도메인별로 서비스를 구성하는 전략도 가능합니다.

3단계 : 서비스별로 API를 정의하는 일입니다. API 구현 시 사용할 IPC도 정해야 합니다.

<br>

분해 과정에서 장애물이 많습니다.

첫 째로 네트워크 지연입니다. 서비스 간 왕복이 너무 잦아 실제로 분해할 수 없는 경우도 있습니다.

둘 째로 서비스 간 동기 통신으로 인해 가용성이 떨어지는 문제입니다.  해결책은 자기 완비형 서비스 개념으로 3장에서 다룹니다.

셋 째로 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건입니다. 이 문제는 보통 사가로 해결합니다.

넷 째로 애플리케이션 도처에 숨어 있는 만능 클라스입니다. 이런 클래스는 DDD 개념을 활용하면 어렵지 않게 제거할 수 있습니다.

<br>

## 2.2.1 시스템 작업 식별

가장 먼저 시스템 작업을 정의하는 일입니다.

우선 사용자 스토리와 이와 연관된 사용자 시나리오 등의 애플리케이션 요건을 정의합니다.

1단계는 시스템 작업을 기술하기 위해 필요한 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성하는 것입니다.

2단계는 시스템 작업 식별 후 그 동작을 모델 관점에서 기술하는 것입니다.

![image-20211002214009533](../images/Chapter02/시스템작업식별.png)

<br>

### 고수준 도메인 모델 생성

시스템 작업을 정의하려면 우선 고수준의 애플리케이션 도메인 모델을 대략 그려 봅니다.

도메인 모델은 스토리에 포함된 명사를 분석하고 도메인 전문가와 상담하는 등 표준 기법을 활용하여 생성합니다.

예를 들어 주문하기 스토리는 다음과 같이 다양한 사용자 시나리오로 확장시킬 수 있습니다.

```
전제(Given)
	소비자가 있다
	음식점이 있다
	음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다
	주문 총액이 음식점의 최소 주문량 조건에 부합한다
	
조건(When)
	소비자가 음식점에 음식을 주문한다
	
결과(Then)
	소비자 신용카드가 승인된다
	주문이 PENDING_ACCEPTANCE 상태로 생성된다
	생성된 주문이 소비자와 연관된다
	생성된 주문이 음식점과 연관된다
```



마찬가지로 주문 접수 스토리는 다음 시나리오로 확장할 수 있습니다.

```
전제(Given)
	현재 주문은 PENDING_ACCEPTANCE 상태다
	주문 배달 가능한 배달원이 있다
	
조건(When)
	주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다
	
결과(Then)
	주문 상태가 ACCEPTED로 변경된다
	주문의 promiseByTime 값을 음식점이 준비하기로 약속한 시간으로 업데이트한다
	주문을 배달할 배달원을 배정한다
```



이를 통해서 도매인 모델이 완성됩니다.

![image-20211002215123204](../images/Chapter02/도메인모델.png)

<br>

### 시스템 작업 정의

애플리케이션이 어떤 요청을 처리할 지 식별하는 단계입니다.

시스템 작업은 크게 다음 두 종류로 나뉩니다.

* 커맨드 : 데이터 생성, 수정, 삭제
* 쿼리 : 데이터 읽기



#### 커맨드

시스템 커맨드를 식별하려면 사용자 스토리/시나리오에 포함된 동사를 먼저 분석합니다.

![image-20211002215831465](../images/Chapter02/시스템커맨드.png)

커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의합니다.

이 명세는 작업 호출 시 충족되어야 할 선행 조건, 작업 호출 후 충족되어야 할 후행 조건으로 구성됩니다.

아래는 createOrder() 시스템 작업의 명세 예시입니다.

![image-20211002220050305](../images/Chapter02/시스템작업명세.png)



다음은 acceptOrder() 시스템 작업의 명세입니다.

![image-20211002220255705](../images/Chapter02/시스템작업명세2.png)

<br>

#### 쿼리

사용자가 의사 결정을 하는데 필요한 정보를 UI에 제공하는 쿼리를 제공해야 합니다.

소비자가 주문을 하는 과정을 떠올려 보면 이렇습니다.

1. 사용자는 배달 주소 및 시간을 입력합니다.
2. 시스템은 배달 가능한 음식점을 표시합니다.
3. 사용자는 음식점을 고릅니다.
4. 시스템은 메뉴를 표시합니다.
5. 사용자는 원하는 메뉴를 선택한 후 체크아웃합니다.
6. 시스템은 주문을 생성합니다.



이런 시나리오면 쿼리가 2개 필요할 것입니다.

* findAvailableRestaurants(deliveryAddress, deliveryTime) : 주어진 장소/시간으로 배달 가능한 음식점 목록을 조회
* findRestaurantMenu(id) : 메뉴 항목 등 음식점 정보를 조회합니다.



<br>

## 2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해

MSA를 구축하는 첫 번째 전략은 비즈니스 능력에 따라 분해하는 것입니다.

<br>

### 비즈니스 능력은 곧 조직이 하는 일이다

비즈니스 능력을 보면 그 조직의 비즈니스가 무엇인지 알 수 있습니다.

조직이 비즈니스를 하는 방법은 그 때마다 다르고 급격히 변하기도 하지만 비즈니스 능력은 대체로 크게 달라지지 않습니다.

예를 들어 수표를 예금하는 방식은 항상 존재하지만 과거에는 은행에 직접 가서, 요즘은 스마트폰으로 간편하게 처리합니다.

<br>



### 비즈니스 능력 식별

한 조직의 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별합니다.

사실 기술보다 비즈니스 위주라는 점만 제외하면 일종의 서비스로 볼 수도 있습니다.

<br>

### 비즈니스 능력을 여러 서비스로 

비즈니스 능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의합니다.



<br>

## 2.2.3 서비스 정의: 하위 도메인 패턴별 분해

DDD는 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법입니다.

도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법입니다.

DDD는 팀에서 사용할 공용 언어를 정의합니다.

DDD에는 MSA에 적용하면 정말 유용한 하위 도메인과 경계 컨텍스트 개념이 있습니다.

<br>



기존에는 전체 비즈니스를 포괄하는 단일 통합 모델을 만들었습니다.

이렇게 모델링하면 하나의 모델에 대해 조직 내 여러 부서의 합의를 이끌어 내기가 정말 어려운 단점이 있습니다.

특정 모델은 어느 부서에서는 아주 복잡하고, 다른 부서에서는 굳이 복잡할 필요가 없을 수 있죠.

DDD는 범위가 분명한 도메인 모델을 여러 개 정의하여 기존 방식의 문제점을 해결하는 전혀 다른 방식의 모델링입니다.

<br>

DDD는 도메인을 구성하는 각 하위 도메인마다 도메인 모델을 따로 정의합니다.

하위 도메인은 비즈니스 능력과 같은 방법으로 식별하므로 십중팔구 비즈니스 능력과 유사한 하위 도메인이 도출됩니다.

FTGO의 하위 도메인은 주문 접수, 주문 관리, 주방 관리, 배달, 재무 등이 있습니다.

<br>

도메인 모델의 범위를 DDD 용어로는 경계
