# 2.2 마이크로서비스 아키텍쳐 정의

이 장에서는 애플리케이션 아키텍쳐를 정의하는 3단계 프로세스를 설명합니다.

![image-20211002193322345](../images/Chapter02/MSA정의프로세스1.png)

![image-20211002193332957](../images/Chapter02/MSA정의프로세스2.png)

1단계 : 애플리케이션 요건을 핵심 요청으로 추출하는 것입니다.

2단계 : 어떻게 여러 서비스로 분해할지 결정하는 것입니다. 비즈니스 능력에 따라 서비스를 정의할 수도 있고 DDD의 하위 도메인별로 서비스를 구성하는 전략도 가능합니다.

3단계 : 서비스별로 API를 정의하는 일입니다. API 구현 시 사용할 IPC도 정해야 합니다.

<br>

분해 과정에서 장애물이 많습니다.

첫 째로 네트워크 지연입니다. 서비스 간 왕복이 너무 잦아 실제로 분해할 수 없는 경우도 있습니다.

둘 째로 서비스 간 동기 통신으로 인해 가용성이 떨어지는 문제입니다.  해결책은 자기 완비형 서비스 개념으로 3장에서 다룹니다.

셋 째로 여러 서비스에 걸쳐 데이터 일관성을 지키는 요건입니다. 이 문제는 보통 사가로 해결합니다.

넷 째로 애플리케이션 도처에 숨어 있는 만능 클라스입니다. 이런 클래스는 DDD 개념을 활용하면 어렵지 않게 제거할 수 있습니다.

<br>

## 2.2.1 시스템 작업 식별

가장 먼저 시스템 작업을 정의하는 일입니다.

우선 사용자 스토리와 이와 연관된 사용자 시나리오 등의 애플리케이션 요건을 정의합니다.

1단계는 시스템 작업을 기술하기 위해 필요한 보케블러리를 제공하는 핵심 클래스로 구성된 고수준의 도메인 모델을 생성하는 것입니다.

2단계는 시스템 작업 식별 후 그 동작을 모델 관점에서 기술하는 것입니다.

![image-20211002214009533](../images/Chapter02/시스템작업식별.png)

<br>

### 고수준 도메인 모델 생성

시스템 작업을 정의하려면 우선 고수준의 애플리케이션 도메인 모델을 대략 그려 봅니다.

도메인 모델은 스토리에 포함된 명사를 분석하고 도메인 전문가와 상담하는 등 표준 기법을 활용하여 생성합니다.

예를 들어 주문하기 스토리는 다음과 같이 다양한 사용자 시나리오로 확장시킬 수 있습니다.

```
전제(Given)
	소비자가 있다
	음식점이 있다
	음식점은 소비자의 주소로 제시간에 음식을 배달할 수 있다
	주문 총액이 음식점의 최소 주문량 조건에 부합한다
	
조건(When)
	소비자가 음식점에 음식을 주문한다
	
결과(Then)
	소비자 신용카드가 승인된다
	주문이 PENDING_ACCEPTANCE 상태로 생성된다
	생성된 주문이 소비자와 연관된다
	생성된 주문이 음식점과 연관된다
```



마찬가지로 주문 접수 스토리는 다음 시나리오로 확장할 수 있습니다.

```
전제(Given)
	현재 주문은 PENDING_ACCEPTANCE 상태다
	주문 배달 가능한 배달원이 있다
	
조건(When)
	주문을 접수한 음식점은 언제까지 음식을 준비할 수 있다고 약속한다
	
결과(Then)
	주문 상태가 ACCEPTED로 변경된다
	주문의 promiseByTime 값을 음식점이 준비하기로 약속한 시간으로 업데이트한다
	주문을 배달할 배달원을 배정한다
```



이를 통해서 도매인 모델이 완성됩니다.

![image-20211002215123204](../images/Chapter02/도메인모델.png)

<br>

### 시스템 작업 정의

애플리케이션이 어떤 요청을 처리할 지 식별하는 단계입니다.

시스템 작업은 크게 다음 두 종류로 나뉩니다.

* 커맨드 : 데이터 생성, 수정, 삭제
* 쿼리 : 데이터 읽기



#### 커맨드

시스템 커맨드를 식별하려면 사용자 스토리/시나리오에 포함된 동사를 먼저 분석합니다.

![image-20211002215831465](../images/Chapter02/시스템커맨드.png)

커맨드는 매개변수, 반환값, 동작 방식의 명세를 도메인 모델 클래스로 정의합니다.

이 명세는 작업 호출 시 충족되어야 할 선행 조건, 작업 호출 후 충족되어야 할 후행 조건으로 구성됩니다.

아래는 createOrder() 시스템 작업의 명세 예시입니다.

![image-20211002220050305](../images/Chapter02/시스템작업명세.png)



다음은 acceptOrder() 시스템 작업의 명세입니다.

![image-20211002220255705](../images/Chapter02/시스템작업명세2.png)

<br>

#### 쿼리

사용자가 의사 결정을 하는데 필요한 정보를 UI에 제공하는 쿼리를 제공해야 합니다.

소비자가 주문을 하는 과정을 떠올려 보면 이렇습니다.

1. 사용자는 배달 주소 및 시간을 입력합니다.
2. 시스템은 배달 가능한 음식점을 표시합니다.
3. 사용자는 음식점을 고릅니다.
4. 시스템은 메뉴를 표시합니다.
5. 사용자는 원하는 메뉴를 선택한 후 체크아웃합니다.
6. 시스템은 주문을 생성합니다.



이런 시나리오면 쿼리가 2개 필요할 것입니다.

* findAvailableRestaurants(deliveryAddress, deliveryTime) : 주어진 장소/시간으로 배달 가능한 음식점 목록을 조회
* findRestaurantMenu(id) : 메뉴 항목 등 음식점 정보를 조회합니다.



<br>

## 2.2.2 서비스 정의: 비즈니스 능력 패턴별 분해

MSA를 구축하는 첫 번째 전략은 비즈니스 능력에 따라 분해하는 것입니다.

비즈니스 능력이란 비즈니스가 가치를 생산하기 위해 하는 일을 말합니다.

비즈니스 능력은 업종마다 다른데, 

보험회사라면 증권 인수, 클레임 관리, 과금, 컴플라이언스 등의 능력이 있고

온라인 쇼핑몰이라면 주문 관리, 재고 관리, 선적 등의 능력이 있을 것입니다.

<br>

### 비즈니스 능력은 곧 조직이 하는 일이다

비즈니스 능력을 보면 그 조직의 비즈니스가 무엇인지 알 수 있습니다.

조직이 비즈니스를 하는 방법은 그 때마다 다르고 급격히 변하기도 하지만 비즈니스 능력은 대체로 크게 달라지지 않습니다.

예를 들어 수표를 예금하는 방식은 항상 존재하지만 과거에는 은행에 직접 가서, 요즘은 스마트폰으로 간편하게 처리합니다.

<br>



### 비즈니스 능력 식별

한 조직의 비즈니스 능력은 조직의 목표, 구조, 비즈니스 프로세스를 분석하여 식별합니다.

사실 기술보다 비즈니스 위주라는 점만 제외하면 일종의 서비스로 볼 수도 있습니다.

비즈니스 능력은 보통 특정 비즈니스 객체에 집중하며, 여러 개의 하위 능력으로 분해할 수 있습니다.

클레임이라는 비즈니스 객체는 클레임 관리 능력을 중심으로 클레임 정보 관리, 클레임 컴토, 클레임 지불 관리 등의 하위 능력이 있습니다.

FTGO의 비즈니스 능력도 어렵지 않게 도출할 수 있습니다.

* 공급자 관리
  * 배달원 관리 : 배달 정보 관리
  * 음식점 정보 관리 : 음식점 메뉴, 위치, 영업 시간, 기타 정보 관리
* 소비자 관리 : 소비자에 관한 정보 관리
* 주문 접수 및 이행
  * 주문 관리 : 소비자가 주문을 생성/관리할 수 있게 합니다.
  * 음식점 주문 관리 : 음식점의 주문 준비 상태를 관리
  * 로지스틱스
  * 배달원 가용성 관리 : 배달원이 배달 가능한지 실시간 관리
  * 배달 관리 : 주문을 소비자에게 배달
* 회계
  * 소비자 회계 : 소비자 과금 관리
  * 음식점 회계 : 음식점 지불 관리
  * 배달원 회계 : 배달원 지불 관리



<br>

### 비즈니스 능력을 여러 서비스로 

비즈니스 능력을 식별한 후 능력에 따라 또는 연관된 능력 그룹에 따라 서비스를 정의합니다.

FTGO의 비즈니스 능력을 애플리케이션 서비스에 매핑한 것입니다.

![image-20211004164846008](../images/Chapter02/business_to_sevice.png)

능력 체계의 어느 수준을 서비스에 매핑할지는 주관적으로 판단할 문제지만 아래 사항을 고려하는 것이 좋습니다.

* 공급자 관리 능력의 두 하위 능력은 각각 두 서비스로 매핑하였습니다. 음식점과 배달원은 전혀 다른 성격의 공급자이기 때문입니다.
* 주문 접수 및 이행 능력은 서비스마다 상이한 프로세스 단계를 담당하도록 세 서비스로 매핑했습니다. 배달원 가용성 관리와 배달 관리 능력은 밀접한 연관이 있으니 한 서비스로 묶었습니다.
* 회계 능력은 유형별 회계가 대동소이하기 때문에 자체 서비스에 매핑했습니다.



이렇게 서비스를 거의 변하지 않는 비즈니스 능력에 따라 구성하면 비교적 안정적인 아키텍쳐를 구축할 수 있습니다.

<br>

## 2.2.3 서비스 정의: 하위 도메인 패턴별 분해

DDD는 객체 지향 도메인 모델 중심의 복잡한 소프트웨어 애플리케이션을 구축하는 방법입니다.

도메인 내부에서 문제 해결이 가능한 형태로 도메인을 모델링하는 기법입니다.

DDD는 팀에서 사용할 공용 언어를 정의합니다.

DDD에는 MSA에 적용하면 정말 유용한 하위 도메인과 경계 컨텍스트 개념이 있습니다.

<br>



기존에는 전체 비즈니스를 포괄하는 단일 통합 모델을 만들었습니다.

이렇게 모델링하면 하나의 모델에 대해 조직 내 여러 부서의 합의를 이끌어 내기가 정말 어려운 단점이 있습니다.

특정 모델은 어느 부서에서는 아주 복잡하고, 다른 부서에서는 굳이 복잡할 필요가 없을 수 있죠.

DDD는 범위가 분명한 도메인 모델을 여러 개 정의하여 기존 방식의 문제점을 해결하는 전혀 다른 방식의 모델링입니다.

<br>

DDD는 도메인을 구성하는 각 하위 도메인마다 도메인 모델을 따로 정의합니다.

하위 도메인은 비즈니스 능력과 같은 방법으로 식별하므로 십중팔구 비즈니스 능력과 유사한 하위 도메인이 도출됩니다.

FTGO의 하위 도메인은 주문 접수, 주문 관리, 주방 관리, 배달, 재무 등이 있습니다.

<br>

도메인 모델의 범위를 DDD 용어로는 경계 컨텍스트라고 합니다.

경계 컨텍스트는 도메인 모델을 구현한 코드 아티팩트를 포함하며 MSA에  DDD를 적용하면 각 서비스가 경계 컨텍스트가 됩니다.



각각 자체 도메인 모델을 가진 서비스에 하위 도메인을 매핑한 결과, 아래와 같습니다.

![image-20211004165530348](../images/Chapter02/subdomain_to_service.png)

<br>

DDD와 MSA는 찰떡궁합입니다.

DDD의 하위 도메인, 경계 컨텍스트 개념은 MSA의 서비스와 잘 맞고,

MSA의 서비스 자율 팀 개념은 도메인 모델을 개별 팀이 소유/개발한다는 DDD의 사고방식과 어울립니다.

자체 도메인 모델을 가진 하위 도메인이라는 개념 덕분에 만능 클래스를 제거하고 서비스로 분해하기가 더 수월해집니다.



<br>

## 2.2.4 분해 지침

비즈니스 능력에 따른 분해, 하위 도메인에 따른 분해는 MSA를 정의하는 주요 수단입니다.

이 밖에도 객체 지향 설계의 근거한 두 가지 원칙이 있습니다.

<br>

### 단일 책임 원칙

소프트웨어 아키텍쳐/설계의 주요 목표 중 하나는 각 소프트웨어 엘리먼트의 책임을 할당하는 것입니다.

단일 책임 원칙은 다음 한 문장으로 표현됩니다.

```
클래스는 오직 하나의 변경 사유를 가져야 한다.
```



클래스가 맡은 책임은 각각 그 클래스가 변경될 잠재적 사유입니다.

클래스가 독립적으로 변경 가능한 책임을 여럿 짊어지고 있다면 안정적일 수 없습니다.

따라서 SRP에 따라 단일 책임을 가진, 즉 변경 사유가 오직 하나인 클래스를 정의하라는 것입니다.

이 원칙을 MSA에 적용하면 하나의 책임만 가진 작고 응집된 서비스를 정의할 수 있습니다.

덕분에 더 작고 안정된 서비스를 만들 수 있습니다.

<br>



### 공동 폐쇄 원칙

CCP(Common Closure Principle)은 아래 문장으로 설명합니다.

```
패키지의 클래스들은 동일한 유형의 변경에 대해 닫혀 있어야 한다. 패키지에 영향을 주는 변경은 그 패키지에 속한 모든 클래스에 영향을 끼친다.
```



어떤 두 클래스가 동일한 사유로 맞물려 변경되면 동일한 패키지에 있어야 한다는 것입니다.

동일한 비즈니스 규칙도 상이한 측면을 구현한 클래스가 여럿 있을 수 있습니다.

이 비즈니스 규칙이 나중에 바뀌어도 개발자는 가급적 소수의 패키지에 있는 코드만 고치면 될 수 있게 만들자는 것입니다.

CCP를 잘 지키면 애플리케이션의 유지보수성이 현저히 향상됩니다.

이를 MSA에 적용하면 동일한 사유로 변경되는 컴포넌트를 모두 같은 서비스로 묶을 수 있습니다.

<br>



## 2.2.5 서비스 분해의 장애물

비즈니스 능력과 하위 도메인별로 서비스를 정의해서 MSA를 구축하는 전략은 장애 요소가 많습니다.

* 네트워크 지연
* 동기 통신으로 인한 가용성 저하
* 여러 서베스에 걸쳐 데이터 일관성 유지
* 데이터의 일관된 뷰 확보
* 분해를 저해하는 만능 클래스

<br>

### 네트워크 지연

서비스를 여러 개로 나누면 서비스 간 왕복 횟수가 급증합니다.

그래서 한 차례 왕복으로 여러 객체를 한 번에 가져오는 배치 API를 구현하거나 값비싼 IPC를 언어 수준의 메서드나 함수 호출로 대체하는 식으로 서비스 결합에 따른 지연 시간을 줄입니다.

<br>

### 동기 IPC로 인한 가용성 저하

REST API를 동기 호출하는 것이 가장 쉬운 방법이지만 비동기 메시징으로 강한 결합도를 제거하고 가용성을 높이는 방법이 더 좋습니다.

<br>

### 여러 서비스에 걸쳐 데이터 일관성 유지

이를 위해 사가(saga)라는 방식으로 트랜잭션을 관리합니다.

사가는 메시징을 이용한 일련의 로컬 트랜잭션으로서 단점은 최종 일관성을 보장한다는 것 입니다.

<br>

### 일관된 데이터 뷰 확보

여러 DB에 걸쳐 일관된 데이터 뷰를 확보하기도 어렵습니다.

MSA에서는 각 서비스의 DB가 일관적이라 해도 전역 범위에서 일관된 데이터 뷰는 확보할 수 없습니다.

<br>

### 만능 클래스는 분해의 걸림돌

애플리케이션 곳곳에 사용되는 만능 클래스는 그 존재만으로도 분해의 걸림돌입니다.

이런 클래스에는 대부분 애플리케이션의 여러 측면에 관한 비즈니스 로직이 있는데, 
