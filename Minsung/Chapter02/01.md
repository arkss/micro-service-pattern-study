# 2.1 마이크로서비스 아키텍쳐 무엇인가?

이 장에서는 마이크로서비스를 정의하는 방법을 다룹니다.

다양한 전략을 살펴보며 서비스가 기술 관심사보다는 비즈니스 관심사를 중심으로 구성된다는 사실을 배우게 될 것 입니다.



<br>

## 2.1.1 소프트웨어 아키텍쳐의 정의와 중요성

### 소프트웨어 아키텍쳐의 정의

소프트웨어 아키텍쳐를 정의한 문구는 다양합니다.

그 중 렌 바스의 스프트웨어 공학 연구소는 아래와 같이 정의합니다.

```
컴퓨터 시스템의 소프트웨어 아키텍쳐는 소프트웨어 엘리먼트와 그들 간의 관계, 그리고 이 둘의 속성으로 구성된 시스템을 추론하는 데 필요한 구조의 집합이다.
```

추상적이지만 핵심은 애플리케이션 아키텍쳐가 여러 파트로의 분해와 이런 파트 간의 관계라는 것입니다.

분해가 중요한 이유는 다음 두 가지 때문입니다.

* 업무와 지식을 분리합니다. 덕분에 전문 지식을 보유한 사람들이 함께 생상적으로 애플리케이션 작업을 할 수 있습니다.
* 소프트웨어 엘리먼트가 어떻게 상호 작용하는지 밝힙니다.



<br>

### 소프트웨어 아키텍쳐의 4+1 뷰 모델

4+1 모델은 소프트웨어 아키텍처를 바라보는 상이한 4뷰를 정의합니다.

각 뷰는 아키텍쳐의 특정한 측면을 기술하고 특정 소프트웨어 엘리먼트와 그 들 사이의 관계로 구성됩니다.

각 뷰의 목적은 다음과 같습니다.

* 논리 뷰 : 개발자가 작성한 소프트웨어 엘리먼트, 객체 지향 언어라면 클래스, 패키지가 해당되며 결국 상속, 연관, 의존 등 클래스와 패키지의 관계를 말합니다.
* 구현 뷰 : 빌드 시스템의 결과물. 모듈과 컴포넌트로 구성됩니다. 자바에서 모듈은 보통 JAR 파일, 컴포넌트는 WAR 파일이나 실행 가능한 JAR 파일입니다. 모듈 간 디펜던시와 컴포넌트/모듈 간 조합 관계도 이 뷰에 포함됩니다.
* 프로세스 뷰 : 런타임 컴포넌트. 각 엘리먼트는 개별 프로세스고 IPC는 프로세스 간 관계를 나타냅니다.
* 배포 뷰 : 프로세스가 머신에 매핑되는 방법. 이 뷰의 엘리먼트는 머신 및 프로세스고, 머신 간의 관계가 바로 네트워킹입니다.

![image-20211001184904531](../images/Chapter02/4+1뷰.png)



위에서 설명한 4뷰 외에도 뷰를 구동시키는 시나리오가 있습니다.

이 시나리오가 +1에 해당합니다.

각 시나리오는 특정 뷰 내에서 얼마나 다양한 아키텍쳐 요소가 협동하여 요청을 처리하는지 기술합니다.

다시 정리하면, 4뷰는 중요한 아키테쳐 측면을, 시나리오는 뷰의 여러 엘리먼트가 협동하는 과정을 명시합니다.



<br>

## 2.1.2 아키텍쳐 스타일 개요

애플리케이션은 대부분 아키텍쳐 스타일을 조합해서 사용합니다.

모놀리식 아키텍쳐도 구현 뷰를 하나의 컴포넌트로 구성한 아키텍쳐 스타일이라고 할 수 있죠.

MSA는 애플리케이션을 느슨하게 결합된 여러 서비스로 구성하는 아키텍쳐 스타일입니다.

<br>

### 계층화 아키텍쳐 스타일

소프트웨어 엘리먼트를 계층별로 구성하는 계층화 아키텍쳐는 전형적인 아키텍쳐 스타일입니다.

계층마다 명확히 정의된 역할을 분담하며, 계층 간 디펜던시는 아키텍쳐로 제한합니다.

따라서 어떤 계층은 바로 하위에 있는 계층에만 의존하거나 하위에 위치한 어느 한 계층에 의존합니다.



계층화 아키텍쳐는 앞서 배운 4뷰 모두 적용할 수 있습니다.

3계층 아키텍쳐가 바로 계층화 아키텍쳐를 논리 뷰에 적용한 사례로 아래와 같이 세 계층으로 구성됩니다.

* 표현 계층 : 사용자 인터페이스 또는 외부 API가 구현된 계층
* 비즈니스 로직 계층 : 비즈니스 로직이 구현된 계층
* 영속화 계층 : DB 상호 작용 로직이 구현된 계층



하지만 계층화 아키텍쳐는 몇 가지 문제점이 있습니다.

* 표현 계층이 하나뿐이다 : 애플리케이션을 호출하는 시스템이 하나밖에 없을까?
* 영속화 계층이 하나뿐이다 : 애플리케이션이 상호 작용하는 DB가 정말 하나뿐일까?
* 비즈니스 로직 계층을 영속화 계층에 의존하는 형태로 정의한다 : 이론적으로 이런 데펜던시 때문에 DB 없이 비즈니스 로직을 테스트하는 것은 불가능합니다.



<br>

### 육각형 아키텍쳐 스타일

육각형 아키텍쳐는 논리 뷰를 비즈니스 로직 중심으로 구성하는 계층화 아키텍쳐 스타일의 대안입니다.

애플리케이션에 표현 계층 대신 비즈니스 로직을 호출하여 외부에서 들어온 요청을 처리하는 인바운드 어댑터와 영속화 계층 대신 비즈니스 로직에 의해 호출되고 외부 애플리케이션을 호출하는 아웃바운드 어댑터를 둡니다.

인바운드 어댑터 : 외부 애플리케이션이 비즈니스 로직을 호출하는 어댑터

아웃바운드 어댑터 : 비즈니스 로직이 외부 시스템을 호출하는 어댑터

비즈니스 로직이 어댑터에 전혀 의존하지 않는다는 것이 이 아키텍쳐의 가장 중요한 특징입니다.

![image-20211002173418204](../images/Chapter02/육각형아키텍쳐.png)



육각형 아키텍쳐 스타일의 가장 큰 장점은 비즈니스 로직에 있던 표현/데이터 접근 로직이 어댑터와 분리되었기 때문에 비즈니스 로직이 표현/데이터 접근 로직 어디에도 의존하지 않는다는 점입니다.



## 2.1.3 마이크로서비스 아키텍쳐는 일종의 아키텍쳐 스타일이다

모놀리식 아키텍쳐는 구현 뷰를 단일 컴포넌트로 구성한 아키텍쳐 스타일입니다.

마이크로서비스 아키텍쳐도 일종의 아키텍쳐 스타일입니다.

하지만 구현 뷰를 다수의 컴포넌트로 구성하는 차이점이 있습니다.

여기서 컴포넌트는 곧 서비스이고, 각 서비스는 자체 논리 뷰 아키텍쳐를 갖고 있습니다.

커넥터는 이런 서비스가 서로 협동할 수 있게 해주는 통신 프로토콜입니다.



<br>

### 서비스란 무엇인가?

서비스는 어떤 기능이 구현되어 단독 배포가 가능한 소프트웨어 컴포넌트입니다.

서비스 API는 내부 구현 상세를 캡슐화합니다.

각각의 마이크로서비스는 자체 아키텍쳐를 가지고 있기 때문에 기술 스택을 독자적으로 구축할 수 있지만 대부분 육각형 아키텍쳐 형태를 취합니다.

API는 서비스에 구현된 비즈니스 로직과 소통하는 어댑터를 이용하여 구현합니다.

작업 어댑터는 비즈니스 로직을 호출하고 이번트 어댑터는 비즈니스 로직이 내어 준 이벤트를 발행합니다.



<br>

### 느슨한 결합

느슨하게 결합된 서비스는 MSA의 주요 특성 중 하나입니다.

서비스는 구현 코드를 감싼 API를 통해서만 상호 작용하므로 클라이언트에 영향을 끼치지 않고 서비스 내부 구현 코드를 바꿀 수 있습니다.

느슨하게 결합된 서비스는 유지보수성, 테스트성을 높이고 애플리케이션 개발 시간을 단축하는 효과가 있습니다.

무엇보다 개발자가 서비스를 이해하고, 변경하고 테스트하기가 더 쉽습니다.



서비스는 느슨하게 결합되고 API를 통해서만 동작하기 때문에 서비스가 직접 DB와 통신하는 일은 불가능합니다.

서비스가 DB 테이블을 서로 공유하지 않기 때문에 런타임 격리도 향상됩니다.

어떤 서비스가 DB락을 획득하여 다른 서비스를 블로킹하는 일 자체가 불가능하게 됩니다.

물론 DB를 공유하지 않기 때문에 여러 서비스에 걸쳐 데이터를 쿼리하고 일관성을 유지하는 일은 더 복잡해지는 단점이 있습니다.



<br>

### 공유 라이브러리 역할

코드 중복을 방지하기 위해 여러 애플리케이션에서 재사용 가능한 기능을 라이브러리로 패키징하는 것은 개발자에게 당연한 일입니다.

MSA에서도 공유 라이브러리를 사용하여 서비스 코드 중복을 줄이는 것은 좋지만 의도치 않은 서비스 간 결합도를 유발하지 않도록 조심해야 합니다.

예를 들어 Order라는 비즈니스 객체를 여러 서비스가 업데이트하는 상황을 생각해봅시다.

필요한 공용 기능을 라이브러리 하나에 모두 패키징해 배포하면 코드 중복은 막을 수 있지만 문제가 발생할 수 있습니다.

나중에 요건이 Order에 영향을 주는 방향으로 변경되면 관련 서비스를 일제히 다시 빌드해서 재배포해야합니다.

이렇게 변경 가능성이 조금이라도 있는 기능이라면 별도의 서비스로 구현하는 것이 낫습니다.



<br>

### 서비스의 규모는 별로 중요하지 않다

마이크로라는 단어 때문에 서비스를 아주 작게 만들어야 할 것 같은 느낌이 들지만 사실 크기가 중요한 것이 아닙니다.

크기보다는 작은 팀이 가장 짧은 시간에 다른 팀과 협동하는 분을 최소로 하여 개발 가능한 서비스를 설계해야 합니다.
