# 4.3 비격리 문제 처리

ACID의 I는 격리성을 의미하며 동시에 실행중인 여러 트랜잭션의 결과가 어떤 순서대로 실행된 결과와 동일함을 보장하는 속성입니다.

사가는 격리성이 빠져 있어 두 가지 문제를 야기합니다.

1. 한 사가가 실행 중에 접근하는 데이터를 도중에 다른 사가가 바꿔치기 할 수 있습니다.
2. 한 사가가 업데이트를 하기 이전 데이터를 다른 사가가 읽을 수 있어서 데이터 일관성이 깨질 수 있습니다.



사가는 사실 ACD 트랜잭션으로 보아야 합니다.

* 원자성(Atomicity) : 사가는 트랜잭션을 모두 완료하거나 모든 변경분을 언두해야 합니다.
* 일관성(Consistency) : 서비스 내부의 참조 무결성은 로컬 DB가 여러 서비스에 걸친 참조 무결성은 서비스가 처리합니다.
* 지속성(Durability) : 로컬 DB로 처리합니다.



격리가 안되면 DB용어로 비정상(anomaly)이 나타날 가능성이 있습니다.

<br>

## 4.3.1 비정상 개요

비격리로 인한 비정상은 다음과 같이 정리할 수 있습니다.

* 소실된 업데이트(lost updates) : 한 사가의 변경분을 다른 사가가 미처 못 읽고 덮어 씁니다.
* 더티 읽기(dirty reads) : 사가 업데이트를 하지 않은 변경분을 다른 트랜잭션이나 사가가 읽습니다.
* 퍼지/반복 불가능한 읽기(fuzzy/nonrepeatable reads) : 한 사가의 상이한 두 단계가 같은 데이터를 읽어도 결과가 달라지는 현상. 다른 사가가 그 사이 업데이트를 했기 때문에 생기는 문제입니다.

<br>

### 소실된 업데이트

소실된 업데이트는 한 사가의 변경분을 다른 사가가 덮어 쓸 때 일어납니다.

1. 주문 생성 사가 첫 번째 단계에서 주문을 생성합니다.
2. 사가 실행 중 주문 취소 사가가 주문을 취소합니다.
3. 주문 생성 사가 마지막 단계에서 주문을 승인합니다.

<br>

### 더티 읽기

한 사가가 업데이트 중인 데이터를 다른 사가가 읽을 때 발생합니다.

소비자들의 신용 한도가 정해져 있고 주문 취소 사가는 다음과 같은 트랜잭션으로 구성됩니다.

* 소비자 서비스 : 신용 잔고를 늘립니다.
* 주문 서비스 : 주문을 취소 상태로 변경합니다.
* 배달 서비스 : 배달을 취소합니다.



주문 취소 사가와 주문 생성 사가의 실행이 서로 겹쳐 실행 중인데, 소비자가 배달을 취소하기는 너무 늦어서 주문 취소 사가가 돌백되는 경우를 생각해 봅시다.

아래와 같이 순서가 엉킬 가능성이 생깁니다.

1. 주문 취소 사가 : 신용 잔고를 늘립니다.
2. 주문 생성 사가 : 신용 잔고를 줄입니다.
3. 주문 취소 사가 : 신용 잔고를 줄이는 보상 트랜잭션이 가동됩니다.

<br>

## 4.3.2 비격리 대책

앞서 나왔던 *_PENDING 상태도 이상 현상을 예방하는 전략 중 하나입니다.

주문 생성 사가처럼 주문을 업데이트하는 사가는 일단 주문을 *_PENDING 상태로 두고 시작합니다.



<br>

### 사가의 구조

사가는 다음 세 가지 트랜잭션으로 구성됩니다.

* 보상 가능 트랜잭션 : 보상 트랜잭션으로 롤백 가능한 트랜잭션
* 피봇 트랜잭션 : 사가의 진행/중단 지점. 피봇 트랜잭션이 커밋되면 사가는 완료될 때까지 실행됩니다. 피봇 트랜잭션은 최종 보상 가능 트랜잭션이 될 수도 있고 최초 재시도 가능 트랜잭션이 될 수도 있습니다.
* 재시도 가능 트랜잭션 : 피봇 트랜잭션 직후의 트랜잭션으로 반드시 성공합니다.

![image-20211021012007020](../images/Chapter04/saga_transaction.png)

<br>

### 비격리 대책 예시

#### 시맨틱 락

보상 가능 트랜잭션이 생성/수정하는 레코드에 무조건 플래그를 세팅하는 대책입니다.

플래그는 레코드가 아직 커밋 전이라서 변경될지 모른다는 표시를 하는 역할입니다.

플래그를 통해 다른 트랜잭션이 레코드에 접근하지 못하게 락을 걸어놓거나 다른 트랜잭션이 해당 레코드를 처리할 때 조심하도록 경고합니다. 

플래그는 사가가 완료되었을 때는 재시도 가능 트랜잭션에 의해,

사가가 롤백 될 때는 보상 트랜잭션에 의해 해제됩니다.

위에서 설명했던 *_PENDING 상태가 바로 시맨틱 락입니다.

<br>

만약 APPROVAL_PENDING 상태의 주문에 cancelOrder() 커맨드가 들어온다면 어떻게 처리해야할까요?

1. cancelOrder()를 실패 처리하고 클라이언트에 나중에 다시 시도하라고 알립니다. 
2. 락이 해제될 때까지 cancelOrder()를 블로킹합니다.

<br>

### 대책: 교환적 업데이트

업데이트를 교환적으로, 즉 어떤 순서로도 실행 가능하게 설계하면 소실된 업데이트 문제를 방지할 수 있습니다.

예를 들어 Account의 debit()과 credit()은 서로 교환적인 작업입니다.

보상 가능 트랜잭션이 계좌를 인출 후 사가를 롤백시켜야 하는 상황이라면 보상 트랜잭션은 단순히 계좌를 입급해서 업데이트를 언두하면 됩니다.

<br>

### 대책: 비관적 관점

비관적 관점은 더티 읽기로 인한 비즈니스 리스크를 최소화하기 위해 사가 단계의 순서를 재조정하는 것입니다.

주문 최소 사가 단계를 다음과 같이 재조정하면 주문 생성 사가가 신용 잔고를 더티 읽기해서 소비자 신용 한도를 초과하는 주문을 생성할 위험성을 줄일 수 있습니다.

1. 주문 서비스 : 주문을 취소 상태로 변경합니다.
2. 배달 서비스 : 배달을 취소합니다.
3. 회계 서비스 : 신용 잔고를 늘립니다.

이렇게 순서를 바꾸면 신용 잔고는 재시도 가능 트랜잭션에서 증가하므로 더티 읽기 가능성은 사라집니다.

<br>

### 대책: 값 다시 읽기

값 다시 읽기는 소실된 업데이트를 방지하는 대책입니다.

사가가 레코드를 업데이트하기 전에 값을 다시 읽어 값이 변경되지 않았는지 확인하는 것입니다.

값을 다시 읽었더니 변경되었다면 사가를 중단하고 나중에 재시작합니다.

이를 통해 주문 생성 사가에 적용하면 주문이 승인되는 도중 취소되는 불상사를 방지할 수 있습니다.

<br>

### 대책: 버전 파일

버전 파일은 레코드에 수행한 작업을 하나하나 기록하는 대책입니다.

순서가 안맞는 요청을 회계 서비스가 받아 처리하려면 작업이 도착하면 기록해 두었다가 정확한 순서로 실행을 합니다.

주문 생성 사가와 주문 취소 사가가 동시에 실행되고, 주문 취소가 먼저 왔다면 이를 기록하여 나중에 주문 생성 사가에 의한 신용카드 승인 요청이 오면 이를 생략합니다.

<br>

### 대책: 값에 의한

동시성 메커니즘을 선택하는 것입니다.

애플리케이션 차원에서 각 요청의 속성을 보고 사가를 쓸지, 아니면 분산 트랜잭션을 쓸지 판단하는 것입니다.

위험성이 낮은 요청은 지금까지 설명한 대책들을, 위험성이 큰 요청은 분산 트랜잭션을 실행합니다.

