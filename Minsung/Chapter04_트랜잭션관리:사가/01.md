# 4.1 마이크로서비스 아키텍처의 트랜잭션 관리

기존 분산 트랜잭션 관리 기법이 요즘 애플리케이션에 잘 맞지 않는 것은 사실입니다

여러 서비스에 걸친 작업의 데이터 일관성을 유지하려면 ACID 트랜잭션 대신 사가라는 메세지 주도 방식의 로컬 트랜잭션을 사용해야 합니다.

그런데 사가는 ACID에서 I가 빠진 ACD만 지원하고 격리가 되지 않기 때문에 동시 비정상의 영향을 방지하거나 줄일 수 있는 설계 기법을 적용해야 합니다.

<br>

## 4.1.1 분산 트랜잭션의 필요성 

createOrder()은 주문가능한 소비자인지 확인하고, 주문 내역을 확인하고, 소비자의 신용카드를 승인하고, DB에 주문을 생성하는 작업입니다.

모놀리식 아키텍쳐에서는 이를 구현하기 어렵지 않습니다.

스프링의 경우 `@Transactional` 만 붙이면 데이터 일관성이 보장됩니다.

하지만 MSA에서는 서비스마다 DB가 있기 때문에 여러 DB에 걸쳐 데이터 일관성을 유지할 수 있는 수단을 강구해야 합니다.

<br>

## 4.1.2 분산 트랜잭션의 문제점

예전에는 분산 트랜잭션을 이용해서 여러 서비스, DB, 메세지 브로커에 걸쳐 데이터 일관성을 유지했습니다.

X/Open DTP 모델인 X/Open XA는 분산 트랜잭션 관리의 사실상 표준입니다.

> DTP : Distributed Transaction Processing, 분산 트랜잭션 처리

XA는 2단계 커밋을 이용하여 전체 트랜잭션 참여자가 반드시 커밋 아니면 롤백을 하도록 보장합니다.

<br>

분산 트랜잭션은 간단해 보이지만 문제점이 많습니다.

1. NoSQL DB와 현대 메세지 브로커는 분산 트랜잭션을 지원하지 않으므로 분산 트랜잭션이 필수라면 최근 기술을 상당수 포기할 수 밖에 없습니다.
2. 분산 트랜잭션은 참여한 모든 서비스가 모두 가동 중이어야 커밋할 수 있습니다. 즉 트랜잭션 참여 서비스들의 가용성들의 곱이 최종 가용성이 되고 이는 전체 가용성을 낮추게 됩니다. 요즘 아키텍쳐들은 일관성보다 가용성을 더 우선시 하는 편입니다.



이러한 문제들 때문에 요즘 애플리케이션에는 분산 트랜잭션이 잘 맞지 않습니다.

<br>

## 4.1.3 데이터 일관성 유지: 사가 패턴

사가는 MSA에서 분산 트랜잭션 없이 데이터 일관성을 유지하는 메커니즘입니다.

여러 서비스의 데이터를 업데이트하는 시스템 커맨드마다 사가를 하나씩 정의합니다.

사가는 비동기 메세징을 이용하여 편성한 일련의 로컬 트랜잭션입니다.

각 로컬 트랜잭션은 앞서 언급한 ACID 트랜잭션 프레임워크/라이브러리를 이용하여 서비스별 데이터를 업데이트합니다.

<br>

