# 5.2 도메인 모델 설계: DDD 애그리거트 패턴

전통적인 객체 지향 설계에 기반한 도메인 모델은 클래스와 클래스 간 관계를 모아 놓은 것입니다.

![image-20211026215453451](../images/Chapter04/object_domain_model.png)

이럴 경우, 기존 도메인 모델을 보면 비즈니스 객체들의 경계가 불분명합니다.

예를 들면 어느 클래스가 Order라는 비즈니스 객체의 일부인지 분명하지 않습니다.

경계가 불분명하면 MSA에서 문제가 생길 가능성이 높습니다.

<br>

## 5.2.1 불분명한 경계 문제

여러 소비자가 주문하는 상황에서 최소 주문량의 충족 여부를 어떻게 보장할 수 있을까요?

셈과 메리라는 두 소비자가 주문을 하는 동시에 주문이 본인의 예산을 초과했는지 결정한다고 합시다.

샘은 사모사를, 메리는 난을 주문합니다.

애플리케이션 관점에서 두 소비자는 DB에서 주문 및 품목을 조회합니다.

두 사람은 주문 단가를 낮추기 위해 품목을 수정하고, 각자 입장에서 보면 최소 주문량은 충족됩니다.

DB 트랜잭션은 다음 순서대로 갈겁니다.

왼쪽이 메리, 오른쪽이 샘입니다.

![image-20211026221756992](../images/Chapter04/merry_sam_transaction.png)

두 소비자는 두 트랜잭션을 통해 품목을 변경합니다.

첫 번째 트랜잭션은 주문 및 품목을 로드하고, UI는 두번 째 트랜잭션 이전에 최소 주문량이 충족됨을 확인합니다.

두 번째 트랜잭션은 낙관적 오프라인 락으로 품목을 업데이트합니다.

<br>

샘은 X만큼, 메리는 Y만큼 주문 총액을 줄입니다.

결국 이 Order는 더 이상 유효하지 않습니다.

> 왜 유효하지 않은거지? 주문 총액을 줄여서? 근데 왜 두번째 트랜잭션 전에 UI에서 확인을 하지? 당연히 끝나고 해야하는거 아닌가?

하지만 두 소비자가 업데이트한 후에도 애플리케이션은 이 주문이 최소 주문량 조건을 충족한다고 볼 것입니다.

이처럼 비즈니스 객체 일부를 직접 업데이트하면 결과적으로 비즈니스 규칙을 위반하게 됩니다.

<br>

## 5.2.2 aggregate는 경계가 분명하다

aggregate는 한 단위로 취급 가능한 경계 내부의 도메인 객체들입니다.

하나의 루트 엔터티와 하나 이상의 기타 엔터티 + 밸류 객체로 구성됩니다.

비즈니스 객체는 대부분 aggregate로 모델링합니다.



아래 그림은 Order aggregate와 그 경계입니다.

하나의 Order 엔터티와 하나 이상의 OrderLineItem 밸류 객체, 그 밖에 DeliveryInfo, PaymentInfo 등의 밸류 객체로 구성됩니다.

![image-20211026234805598](../images/Chapter04/order_aggregate.png)

aggregate는 도메인 모델을 개별적으로 이해하기 쉬운 덩어리로 분해합니다.

또 로드, 수정, 삭제 같은 작업 범위를 분명하게 설정합니다.

작업은 aggregate 일부가 아닌 전체 aggregate에 적용합니다.

aggregate는 보통 DB에서 통째로 가져오기 때문에 복잡한 지연 로딩 문제를 신경쓸 필요가 없습니다.

그리고 aggregate를 삭제하면 해당 객체가 DB에서 모두 사라집니다.

<br>

### aggregate는 일관된 경계

